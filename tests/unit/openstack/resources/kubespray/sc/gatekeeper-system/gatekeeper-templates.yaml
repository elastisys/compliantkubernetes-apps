---
# Source: gatekeeper-templates/templates/config.yaml
apiVersion: config.gatekeeper.sh/v1alpha1
kind: Config
metadata:
  name: config
  namespace: "gatekeeper-system"
spec:
  sync:
    syncOnly:
      - group: "networking.k8s.io"
        version: "v1"
        kind: "NetworkPolicy"
      - group: "apps"
        version: "v1"
        kind: "Deployment"
      - group: "apps"
        version: "v1"
        kind: "ReplicaSet"
      - group: "apps"
        version: "v1"
        kind: "StatefulSet"
      - group: ""
        version: "v1"
        kind: "ReplicationController"
      - group: "policy"
        version: "v1"
        kind: "PodDisruptionBudget"
---
# Source: gatekeeper-templates/templates/deployment-minimum-replicas/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sminimumreplicas
spec:
  crd:
    spec:
      names:
        kind: K8sMinimumReplicas
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
            type: object
            properties:
              min_replicas:
                description: The minimum number of replicas allowed, inclusive.
                type: integer
              annotation:
                description: This annotation allows to suppress the warning of the constraint if the number of replicas is lower than the required minimum.
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sminimumreplicas
        
        import future.keywords.in
        
        object_name = input.review.object.metadata.name
        object_kind = input.review.kind.kind
        
        violation[{"msg": msg}] {
            spec := input.review.object.spec
            metadata := input.review.object.metadata
            not input_replica_limit(spec)
            not check_annotation(metadata)
            msg := sprintf("The provided number of replicas is too low for %v: %v. Elastisys Welkin® recommends a minimum of 2 replicas. More Info: https://elastisys.io/welkin/user-guide/safeguards/enforce-minimum-replicas", [object_kind, object_name])
        }
        
        input_replica_limit(spec) {
            provided := spec.replicas
            min_replicas := input.parameters.min_replicas
            min_replicas <= provided
        }
        
        check_annotation(metadata) {
            provided := metadata.annotations
            value := input.parameters.annotation
        
            some key, _ in provided
            key == value
        }
---
# Source: gatekeeper-templates/templates/disallow-localhost-seccomp/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sdisallowlocalhostseccomp
spec:
  crd:
    spec:
      names:
        kind: K8sDisallowLocalhostSeccomp
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sdisallowlocalhostseccomp
        
        # For pods
        
        # Violation if pods use Localhost seccompProfile
        violation[{"msg": msg}] {
        
            object := get_pods
        
            object.spec.securityContext.seccompProfile.type == "Localhost"
        
            msg := sprintf("The %v named <%v> uses Localhost seccompProfile. Elastisys Welkin® does not allow the use of Localhost secompProfile.", [object.kind, object.metadata.name])
        }
        
        # Get "Pods"
        get_pods = res {
            input.review.object.kind == "Pod"
            res := input.review.object
        }
        
        # For deployments, statefulsets, daemonsets, replicasets, jobs, replicationcontrollers
        
        # Violation if resources that uses podTemplates use Localhost seccompProfile
        violation[{"msg": msg}] {
        
            object := get_objects
        
            object.spec.template.spec.securityContext.seccompProfile.type == "Localhost"
        
            msg := sprintf("The %v named <%v> uses Localhost seccompProfile in the pod template. Elastisys Welkin® does not allow the use of Localhost secompProfile.", [object.kind, object.metadata.name])
        }
        
        # Get resources that use pod templates.
        get_objects = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object
        }
        
        # For cronjobs
        
        # Violation cronjobs use Localhost seccompProfile
        violation[{"msg": msg}] {
        
            object := get_cronjobs
        
            object.spec.jobTemplate.spec.template.spec.securityContext.seccompProfile.type == "Localhost"
        
            msg := sprintf("The %v named <%v> uses Localhost seccompProfile in the pod template. Elastisys Welkin® does not allow the use of Localhost secompProfile.", [object.kind, object.metadata.name])
        }
        
        # Get "CronJobs"
        get_cronjobs = res {
            input.review.object.kind == "CronJob"
            res := input.review.object
        }
        
        # For regular containers
        
        # Violation if containers use Localhost seccompProfile
        violation[{"msg": msg}] {
        
            container := get_containers[_]
        
            container.securityContext.seccompProfile.type == "Localhost"
        
            msg := sprintf("The container named <%v> uses Localhost seccompProfile. Elastisys Welkin® does not allow the use of Localhost secompProfile.", [container.name])
        }
        
        # Get containers for "Pods"
        get_containers = res {
            pod := get_pods
        
            res := pod.spec.containers
        }
        
        # Get containers for resources that use pod templates.
        get_containers = res {
            object := get_objects
        
            res := object.spec.template.spec.containers
        }
        
        # Get containers for "CronJobs"
        get_containers = res {
            cronjob := get_cronjobs
        
            res := cronjob.spec.jobTemplate.spec.template.spec.containers
        }
        
        # For init containers
        
        # Violation if init containers use Localhost seccompProfile
        violation[{"msg": msg}] {
        
            container := get_init_containers[_]
        
            container.securityContext.seccompProfile.type == "Localhost"
        
            msg := sprintf("The container named <%v> uses Localhost seccompProfile. Elastisys Welkin® does not allow the use of Localhost secompProfile.", [container.name])
        }
        
        # Get init containers for "Pods"
        get_init_containers = res {
            pod := get_pods
        
            res := pod.spec.initContainers
        }
        
        # Get init containers for resources that use pod templates.
        get_init_containers = res {
            object := get_objects
        
            res := object.spec.template.spec.initContainers
        }
        
        # Get init containers for "CronJobs"
        get_init_containers = res {
            cronjob := get_cronjobs
        
            res := cronjob.spec.jobTemplate.spec.template.spec.initContainers
        }
        
        # For ephemeral containers
        
        # Violation if ephemeral containers use Localhost seccompProfile
        violation[{"msg": msg}] {
        
            container := get_ephemeral_containers[_]
        
            container.securityContext.seccompProfile.type == "Localhost"
        
            msg := sprintf("The container named <%v> uses Localhost seccompProfile. Elastisys Welkin® does not allow the use of Localhost secompProfile.", [container.name])
        }
        
        # Get ephemeral containers for "Pods"
        get_ephemeral_containers = res {
            pod := get_pods
        
            res := pod.spec.ephemeralContainers
        }
        
        # Get ephemeral containers for resources that use pod templates.
        get_ephemeral_containers = res {
            object := get_objects
        
            res := object.spec.template.spec.ephemeralContainers
        }
        
        # Get ephemeral containers for "CronJobs"
        get_ephemeral_containers = res {
            cronjob := get_cronjobs
        
            res := cronjob.spec.jobTemplate.spec.template.spec.ephemeralContainers
        }
---
# Source: gatekeeper-templates/templates/disallow-tag/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sdisallowedtags
spec:
  crd:
    spec:
      names:
        kind: K8sDisallowedTags
      validation:
        legacySchema: true
        openAPIV3Schema:
          properties:
            tags:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sdisallowedtags
        
        # For regular containers
        violation[{"msg": msg}] {
        
            container := get_containers[_]
        
            tags := [forbid | tag = input.parameters.tags[_] ; forbid = endswith(container.image, concat(":", ["", tag]))]
            any(tags)
            msg := sprintf("The container named <%v> uses the :latest tag. Elastisys Welkin® requires all images to have explicit tags. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-latest-tag/", [container.name])
        }
        
        violation[{"msg": msg}] {
        
            container := get_containers[_]
        
            tag := [contains(container.image, ":")]
            not all(tag)
            msg := sprintf("The container named <%v> didn't specify an image tag. Elastisys Welkin® requires all images to have tags to avoid the implicit :latest tag. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-latest-tag/", [container.name])
        }
        
        # Get containers for "Pods"
        get_containers = res {
            input.review.object.kind == "Pod"
            res := input.review.object.spec.containers
        }
        
        # Get containers for resources that use pod templates.
        get_containers = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.spec.containers
        }
        
        # Get containers for "CronJobs"
        get_containers = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.spec.containers
        }
        
        # For init containers
        violation[{"msg": msg}] {
        
            container := get_init_containers[_]
        
            tags := [forbid | tag = input.parameters.tags[_] ; forbid = endswith(container.image, concat(":", ["", tag]))]
            any(tags)
            msg := sprintf("The container named <%v> uses the :latest tag. Elastisys Welkin® requires all images to have explicit tags. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-latest-tag/", [container.name])
        }
        
        violation[{"msg": msg}] {
        
            container := get_init_containers[_]
        
            tag := [contains(container.image, ":")]
            not all(tag)
            msg := sprintf("The container named <%v> didn't specify an image tag. Elastisys Welkin® requires all images to have tags to avoid the implicit :latest tag. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-latest-tag/", [container.name])
        }
        
        # Get init containers for "Pods"
        get_init_containers = res {
            input.review.object.kind == "Pod"
            res := input.review.object.spec.initContainers
        }
        
        # Get init containers for resources that use pod templates.
        get_init_containers = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.spec.initContainers
        }
        
        # Get init containers for "CronJobs"
        get_init_containers = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.spec.initContainers
        }
---
# Source: gatekeeper-templates/templates/image-registry/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sallowedrepos
spec:
  crd:
    spec:
      names:
        kind: K8sAllowedRepos
      validation:
        legacySchema: true
        openAPIV3Schema:
          properties:
            repos:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sallowedrepos
        
        # For regular containers
        violation[{"msg": msg}] {
        
            container := get_containers[_]
        
            satisfied := [good | repo = input.parameters.repos[_] ; good = startswith(container.image, repo)]
            not any(satisfied)
            msg := sprintf("The container named <%v> does not have an allowed image registry <%v>, allowed registries are <%v>. Elastisys Welkin® requires that all images come from trusted registries. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-trusted-registries/", [container.name, container.image, input.parameters.repos])
        }
        
        # Get containers for "Pods"
        get_containers = res {
            input.review.object.kind == "Pod"
            res := input.review.object.spec.containers
        }
        
        # Get containers for resources that use pod templates.
        get_containers = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.spec.containers
        }
        
        # Get containers for "CronJobs"
        get_containers = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.spec.containers
        }
        
        # For init containers
        violation[{"msg": msg}] {
        
            container := get_init_containers[_]
        
            satisfied := [good | repo = input.parameters.repos[_] ; good = startswith(container.image, repo)]
            not any(satisfied)
            msg := sprintf("The initContainer named <%v> does not have an allowed image registry <%v>, allowed registries are <%v>. Elastisys Welkin® requires that all images come from trusted registries. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-trusted-registries/", [container.name, container.image, input.parameters.repos])
        }
        
        # Get init containers for "Pods"
        get_init_containers = res {
            input.review.object.kind == "Pod"
            res := input.review.object.spec.initContainers
        }
        
        # Get init containers for resources that use pod templates.
        get_init_containers = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.spec.initContainers
        }
        
        # Get init containers for "CronJobs"
        get_init_containers = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.spec.initContainers
        }
---
# Source: gatekeeper-templates/templates/networkpolicies/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequirenetworkpolicy
spec:
  crd:
    spec:
      names:
        kind: K8sRequireNetworkPolicy
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sRequireNetworkPolicy
        
        violation[{"msg": msg}] {
            # allow modification to pod without network policy after it has been marked
            # for deletion, e.g. changes to finalizers
            not (input.review.object.metadata.deletionTimestamp)
        
            namespace := input.review.object.metadata.namespace
        
            res = [x | x := allChecks(data.inventory.namespace[namespace]["networking.k8s.io/v1"]["NetworkPolicy"][_])]
            all(res) #all networkpolicies failed to match
            msg := sprintf("No matching networkpolicy found. Elastisys Welkin® requires that all pods are targeted by NetworkPolicies. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-networkpolicies/", [])
        }
        
        #Check one networkpolicy, returns true if it does not match
        allChecks(netwPolicy) = res {
            r1 := matchLabelsMissingKeys(netwPolicy)
            r2 := any(matchLabelsValues(netwPolicy))
            r3 := matchExpressionsExists(netwPolicy)
            r4 := matchExpressionsDoesNotExist(netwPolicy)
            r5 := any(matchExpressionsIn(netwPolicy))
            r6 := any(matchExpressionsNotIn(netwPolicy))
            #return true if any part of the networkpolicy does not match
            res := any({r1, r2, r3, r4, r5, r6})
        }
        
        matchLabelsMissingKeys(netwPolicy) = res {
            res3 := {key | netwPolicy.spec.podSelector.matchLabels[key]}
            res4 := {key | get_labels[key]}
            res := count(res3 - res4) != 0
        }
        
        matchLabelsValues(netwPolicy) = res {
            res := [x |
                get_labels[key1] != netwPolicy.spec.podSelector.matchLabels[key3];
                x := key1 == key3]
        }
        
        matchExpressionsExists(netwPolicy) = res {
            keys := { key |
                netwPolicy.spec.podSelector.matchExpressions[i].operator == "Exists"
                key := netwPolicy.spec.podSelector.matchExpressions[i].key}
            inputKeys := {key | get_labels[key]}
            res := count(keys - inputKeys) != 0
        }
        
        matchExpressionsDoesNotExist(netwPolicy) = res {
            keys := { key |
                netwPolicy.spec.podSelector.matchExpressions[i].operator == "DoesNotExist"
                key := netwPolicy.spec.podSelector.matchExpressions[i].key}
            inputKeys := {key | get_labels[key]}
            res := count(keys & inputKeys) != 0
        }
        
        matchExpressionsIn(netwPolicy) = res {
            res := [ x |
                netwPolicy.spec.podSelector.matchExpressions[i].operator == "In"
                key := netwPolicy.spec.podSelector.matchExpressions[i].key
                x := false == any([y | y := get_labels[key] == netwPolicy.spec.podSelector.matchExpressions[i].values[_]])]
        }
        
        matchExpressionsNotIn(netwPolicy) = res {
            res := [ x |
                netwPolicy.spec.podSelector.matchExpressions[i].operator == "NotIn"
                key := netwPolicy.spec.podSelector.matchExpressions[i].key
                x := any([y | y := get_labels[key] == netwPolicy.spec.podSelector.matchExpressions[i].values[_]])]
        }
        
        # Get labels for "Pods"
        get_labels = res {
            input.review.object.kind == "Pod"
            res := input.review.object.metadata.labels
        }
        
        # Get labels for resources that use pod templates.
        get_labels = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.metadata.labels
        }
        
        # Get labels for "CronJobs"
        get_labels = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.metadata.labels
        }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/allow-privilege-escalation.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspallowprivilegeescalationcontainer
  annotations:
    metadata.gatekeeper.sh/title: "Allow Privilege Escalation in Container"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls restricting escalation to root privileges. Corresponds to the
      `allowPrivilegeEscalation` field in a PodSecurityPolicy. For more
      information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowPrivilegeEscalationContainer
      validation:
        openAPIV3Schema:
          type: object
          description: >-
            Controls restricting escalation to root privileges. Corresponds to the
            `allowPrivilegeEscalation` field in a PodSecurityPolicy. For more
            information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspallowprivilegeescalationcontainer

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            c := input_containers[_]
            not is_exempt(c)
            input_allow_privilege_escalation(c)
            msg := sprintf("Privilege escalation container is not allowed: %v", [c.name])
        }

        input_allow_privilege_escalation(c) {
            not has_field(c, "securityContext")
        }
        input_allow_privilege_escalation(c) {
            not c.securityContext.allowPrivilegeEscalation == false
        }
        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/apparmor.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspapparmor
  annotations:
    metadata.gatekeeper.sh/title: "App Armor"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Configures an allow-list of AppArmor profiles for use by containers.
      This corresponds to specific annotations applied to a PodSecurityPolicy.
      For information on AppArmor, see
      https://kubernetes.io/docs/tutorials/clusters/apparmor/
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAppArmor
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Configures an allow-list of AppArmor profiles for use by containers.
            This corresponds to specific annotations applied to a PodSecurityPolicy.
            For information on AppArmor, see
            https://kubernetes.io/docs/tutorials/clusters/apparmor/
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
            allowedProfiles:
              description: "An array of AppArmor profiles. Examples: `runtime/default`, `unconfined`."
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspapparmor

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            metadata := input.review.object.metadata
            container := input_containers[_]
            not is_exempt(container)
            not input_apparmor_allowed(container, metadata)
            msg := sprintf("AppArmor profile is not allowed, pod: %v, container: %v. Allowed profiles: %v", [input.review.object.metadata.name, container.name, input.parameters.allowedProfiles])
        }

        input_apparmor_allowed(container, metadata) {
            get_annotation_for(container, metadata) == input.parameters.allowedProfiles[_]
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }

        get_annotation_for(container, metadata) = out {
            out = metadata.annotations[sprintf("container.apparmor.security.beta.kubernetes.io/%v", [container.name])]
        }
        get_annotation_for(container, metadata) = out {
            not metadata.annotations[sprintf("container.apparmor.security.beta.kubernetes.io/%v", [container.name])]
            out = "runtime/default"
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/capabilities.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspcapabilities
  annotations:
    metadata.gatekeeper.sh/title: "Capabilities"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls Linux capabilities on containers. Corresponds to the
      `allowedCapabilities` and `requiredDropCapabilities` fields in a
      PodSecurityPolicy. For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#capabilities
spec:
  crd:
    spec:
      names:
        kind: K8sPSPCapabilities
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls Linux capabilities on containers. Corresponds to the
            `allowedCapabilities` and `requiredDropCapabilities` fields in a
            PodSecurityPolicy. For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#capabilities
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
            allowedCapabilities:
              type: array
              description: "A list of Linux capabilities that can be added to a container."
              items:
                type: string
            requiredDropCapabilities:
              type: array
              description: "A list of Linux capabilities that are required to be dropped from a container."
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package capabilities

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt(container)
          has_disallowed_capabilities(container)
          msg := sprintf("container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not is_exempt(container)
          missing_drop_capabilities(container)
          msg := sprintf("container <%v> is not dropping all required capabilities. Container must drop all of %v or \"ALL\"", [container.name, input.parameters.requiredDropCapabilities])
        }



        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          not is_exempt(container)
          has_disallowed_capabilities(container)
          msg := sprintf("init container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          not is_exempt(container)
          missing_drop_capabilities(container)
          msg := sprintf("init container <%v> is not dropping all required capabilities. Container must drop all of %v or \"ALL\"", [container.name, input.parameters.requiredDropCapabilities])
        }



        violation[{"msg": msg}] {
          container := input.review.object.spec.ephemeralContainers[_]
          not is_exempt(container)
          has_disallowed_capabilities(container)
          msg := sprintf("ephemeral container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.ephemeralContainers[_]
          not is_exempt(container)
          missing_drop_capabilities(container)
          msg := sprintf("ephemeral container <%v> is not dropping all required capabilities. Container must drop all of %v or \"ALL\"", [container.name, input.parameters.requiredDropCapabilities])
        }


        has_disallowed_capabilities(container) {
          allowed := {c | c := lower(input.parameters.allowedCapabilities[_])}
          not allowed["*"]
          capabilities := {c | c := lower(container.securityContext.capabilities.add[_])}

          count(capabilities - allowed) > 0
        }

        missing_drop_capabilities(container) {
          must_drop := {c | c := lower(input.parameters.requiredDropCapabilities[_])}
          all := {"all"}
          dropped := {c | c := lower(container.securityContext.capabilities.drop[_])}

          count(must_drop - dropped) > 0
          count(all - dropped) > 0
        }

        get_default(obj, param, _default) = out {
          out = obj[param]
        }

        get_default(obj, param, _default) = out {
          not obj[param]
          not obj[param] == false
          out = _default
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/flexvolume-drivers.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspflexvolumes
  annotations:
    metadata.gatekeeper.sh/title: "FlexVolumes"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls the allowlist of FlexVolume drivers. Corresponds to the
      `allowedFlexVolumes` field in PodSecurityPolicy. For more information,
      see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#flexvolume-drivers
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFlexVolumes
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls the allowlist of FlexVolume drivers. Corresponds to the
            `allowedFlexVolumes` field in PodSecurityPolicy. For more information,
            see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#flexvolume-drivers
          properties:
            allowedFlexVolumes:
              type: array
              description: "An array of AllowedFlexVolume objects."
              items:
                type: object
                properties:
                  driver:
                    description: "The name of the FlexVolume driver."
                    type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspflexvolumes

        violation[{"msg": msg, "details": {}}] {
            volume := input_flexvolumes[_]
            not input_flexvolumes_allowed(volume)
            msg := sprintf("FlexVolume %v is not allowed, pod: %v. Allowed drivers: %v", [volume, input.review.object.metadata.name, input.parameters.allowedFlexVolumes])
        }

        input_flexvolumes_allowed(volume) {
            input.parameters.allowedFlexVolumes[_].driver == volume.flexVolume.driver
        }

        input_flexvolumes[v] {
            v := input.review.object.spec.volumes[_]
            has_field(v, "flexVolume")
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/forbidden-sysctls.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspforbiddensysctls
  annotations:
    metadata.gatekeeper.sh/title: "Forbidden Sysctls"
    metadata.gatekeeper.sh/version: 1.1.0
    description: >-
      Controls the `sysctl` profile used by containers. Corresponds to the
      `allowedUnsafeSysctls` and `forbiddenSysctls` fields in a PodSecurityPolicy.
      When specified, any sysctl not in the `allowedSysctls` parameter is considered to be forbidden.
      The `forbiddenSysctls` parameter takes precedence over the `allowedSysctls` parameter.
      For more information, see https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
spec:
  crd:
    spec:
      names:
        kind: K8sPSPForbiddenSysctls
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls the `sysctl` profile used by containers. Corresponds to the
            `allowedUnsafeSysctls` and `forbiddenSysctls` fields in a PodSecurityPolicy.
            When specified, any sysctl not in the `allowedSysctls` parameter is considered to be forbidden.
            The `forbiddenSysctls` parameter takes precedence over the `allowedSysctls` parameter.
            For more information, see https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
          properties:
            allowedSysctls:
              type: array
              description: "An allow-list of sysctls. `*` allows all sysctls not listed in the `forbiddenSysctls` parameter."
              items:
                type: string
            forbiddenSysctls:
              type: array
              description: "A disallow-list of sysctls. `*` forbids all sysctls."
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspforbiddensysctls

        # Block if forbidden
        violation[{"msg": msg, "details": {}}] {
            sysctl := input.review.object.spec.securityContext.sysctls[_].name
            forbidden_sysctl(sysctl)
            msg := sprintf("The sysctl %v is not allowed, pod: %v. Forbidden sysctls: %v", [sysctl, input.review.object.metadata.name, input.parameters.forbiddenSysctls])
        }

        # Block if not explicitly allowed
        violation[{"msg": msg, "details": {}}] {
            sysctl := input.review.object.spec.securityContext.sysctls[_].name
            not allowed_sysctl(sysctl)
            msg := sprintf("The sysctl %v is not explicitly allowed, pod: %v. Allowed sysctls: %v", [sysctl, input.review.object.metadata.name, input.parameters.allowedSysctls])
        }

        # * may be used to forbid all sysctls
        forbidden_sysctl(sysctl) {
            input.parameters.forbiddenSysctls[_] == "*"
        }

        forbidden_sysctl(sysctl) {
            input.parameters.forbiddenSysctls[_] == sysctl
        }

        forbidden_sysctl(sysctl) {
            forbidden := input.parameters.forbiddenSysctls[_]
            endswith(forbidden, "*")
            startswith(sysctl, trim_suffix(forbidden, "*"))
        }

        # * may be used to allow all sysctls
        allowed_sysctl(sysctl) {
            input.parameters.allowedSysctls[_] == "*"
        }

        allowed_sysctl(sysctl) {
            input.parameters.allowedSysctls[_] == sysctl
        }

        allowed_sysctl(sysctl) {
            allowed := input.parameters.allowedSysctls[_]
            endswith(allowed, "*")
            startswith(sysctl, trim_suffix(allowed, "*"))
        }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/fsgroup.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspfsgroup
  annotations:
    metadata.gatekeeper.sh/title: "FS Group"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls allocating an FSGroup that owns the Pod's volumes. Corresponds
      to the `fsGroup` field in a PodSecurityPolicy. For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFSGroup
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls allocating an FSGroup that owns the Pod's volumes. Corresponds
            to the `fsGroup` field in a PodSecurityPolicy. For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
          properties:
            rule:
              description: "An FSGroup rule name."
              enum:
                - MayRunAs
                - MustRunAs
                - RunAsAny
              type: string
            ranges:
              type: array
              description: "GID ranges affected by the rule."
              items:
                type: object
                properties:
                  min:
                    description: "The minimum GID in the range, inclusive."
                    type: integer
                  max:
                    description: "The maximum GID in the range, inclusive."
                    type: integer
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspfsgroup

        violation[{"msg": msg, "details": {}}] {
            spec := input.review.object.spec
            not input_fsGroup_allowed(spec)
            msg := sprintf("The provided pod spec fsGroup is not allowed, pod: %v. Allowed fsGroup: %v", [input.review.object.metadata.name, input.parameters])
        }

        input_fsGroup_allowed(spec) {
            # RunAsAny - No range is required. Allows any fsGroup ID to be specified.
            input.parameters.rule == "RunAsAny"
        }
        input_fsGroup_allowed(spec) {
            # MustRunAs - Validates pod spec fsgroup against all ranges
            input.parameters.rule == "MustRunAs"
            fg := spec.securityContext.fsGroup
            count(input.parameters.ranges) > 0
            range := input.parameters.ranges[_]
            value_within_range(range, fg)
        }
        input_fsGroup_allowed(spec) {
            # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
            input.parameters.rule == "MayRunAs"
            not has_field(spec, "securityContext")
        }
        input_fsGroup_allowed(spec) {
            # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
            input.parameters.rule == "MayRunAs"
            not spec.securityContext.fsGroup
        }
        input_fsGroup_allowed(spec) {
            # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
            input.parameters.rule == "MayRunAs"
            fg := spec.securityContext.fsGroup
            count(input.parameters.ranges) > 0
            range := input.parameters.ranges[_]
            value_within_range(range, fg)
        }
        value_within_range(range, value) {
            range.min <= value
            range.max >= value
        }
        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/host-filesystem.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spsphostfilesystem
  annotations:
    metadata.gatekeeper.sh/title: "Host Filesystem"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls usage of the host filesystem. Corresponds to the
      `allowedHostPaths` field in a PodSecurityPolicy. For more information,
      see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostFilesystem
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls usage of the host filesystem. Corresponds to the
            `allowedHostPaths` field in a PodSecurityPolicy. For more information,
            see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
          properties:
            allowedHostPaths:
              type: array
              description: "An array of hostpath objects, representing paths and read/write configuration."
              items:
                type: object
                properties:
                  pathPrefix:
                    type: string
                    description: "The path prefix that the host volume must match."
                  readOnly:
                    type: boolean
                    description: "when set to true, any container volumeMounts matching the pathPrefix must include `readOnly: true`."
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spsphostfilesystem

        violation[{"msg": msg, "details": {}}] {
            volume := input_hostpath_volumes[_]
            allowedPaths := get_allowed_paths(input)
            input_hostpath_violation(allowedPaths, volume)
            msg := sprintf("HostPath volume %v is not allowed, pod: %v. Allowed path: %v", [volume, input.review.object.metadata.name, allowedPaths])
        }

        input_hostpath_violation(allowedPaths, volume) {
            # An empty list means all host paths are blocked
            allowedPaths == []
        }
        input_hostpath_violation(allowedPaths, volume) {
            not input_hostpath_allowed(allowedPaths, volume)
        }

        get_allowed_paths(arg) = out {
            not arg.parameters
            out = []
        }
        get_allowed_paths(arg) = out {
            not arg.parameters.allowedHostPaths
            out = []
        }
        get_allowed_paths(arg) = out {
            out = arg.parameters.allowedHostPaths
        }

        input_hostpath_allowed(allowedPaths, volume) {
            allowedHostPath := allowedPaths[_]
            path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
            not allowedHostPath.readOnly == true
        }

        input_hostpath_allowed(allowedPaths, volume) {
            allowedHostPath := allowedPaths[_]
            path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
            allowedHostPath.readOnly
            not writeable_input_volume_mounts(volume.name)
        }

        writeable_input_volume_mounts(volume_name) {
            container := input_containers[_]
            mount := container.volumeMounts[_]
            mount.name == volume_name
            not mount.readOnly
        }

        # This allows "/foo", "/foo/", "/foo/bar" etc., but
        # disallows "/fool", "/etc/foo" etc.
        path_matches(prefix, path) {
            a := path_array(prefix)
            b := path_array(path)
            prefix_matches(a, b)
        }
        path_array(p) = out {
            p != "/"
            out := split(trim(p, "/"), "/")
        }
        # This handles the special case for "/", since
        # split(trim("/", "/"), "/") == [""]
        path_array("/") = []

        prefix_matches(a, b) {
            count(a) <= count(b)
            not any_not_equal_upto(a, b, count(a))
        }

        any_not_equal_upto(a, b, n) {
            a[i] != b[i]
            i < n
        }

        input_hostpath_volumes[v] {
            v := input.review.object.spec.volumes[_]
            has_field(v, "hostPath")
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/host-namespaces.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spsphostnamespace
  annotations:
    metadata.gatekeeper.sh/title: "Host Namespace"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Disallows sharing of host PID and IPC namespaces by pod containers.
      Corresponds to the `hostPID` and `hostIPC` fields in a PodSecurityPolicy.
      For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNamespace
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Disallows sharing of host PID and IPC namespaces by pod containers.
            Corresponds to the `hostPID` and `hostIPC` fields in a PodSecurityPolicy.
            For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spsphostnamespace

        violation[{"msg": msg, "details": {}}] {
            input_share_hostnamespace(input.review.object)
            msg := sprintf("Sharing the host namespace is not allowed: %v", [input.review.object.metadata.name])
        }

        input_share_hostnamespace(o) {
            o.spec.hostPID
        }
        input_share_hostnamespace(o) {
            o.spec.hostIPC
        }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/host-network-ports.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spsphostnetworkingports
  annotations:
    metadata.gatekeeper.sh/title: "Host Networking Ports"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls usage of host network namespace by pod containers. Specific
      ports must be specified. Corresponds to the `hostNetwork` and
      `hostPorts` fields in a PodSecurityPolicy. For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNetworkingPorts
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls usage of host network namespace by pod containers. Specific
            ports must be specified. Corresponds to the `hostNetwork` and
            `hostPorts` fields in a PodSecurityPolicy. For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
            hostNetwork:
              description: "Determines if the policy allows the use of HostNetwork in the pod spec."
              type: boolean
            min:
              description: "The start of the allowed port range, inclusive."
              type: integer
            max:
              description: "The end of the allowed port range, inclusive."
              type: integer
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spsphostnetworkingports

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            input_share_hostnetwork(input.review.object)
            msg := sprintf("The specified hostNetwork and hostPort are not allowed, pod: %v. Allowed values: %v", [input.review.object.metadata.name, input.parameters])
        }

        input_share_hostnetwork(o) {
            not input.parameters.hostNetwork
            o.spec.hostNetwork
        }

        input_share_hostnetwork(o) {
            hostPort := input_containers[_].ports[_].hostPort
            hostPort < input.parameters.min
        }

        input_share_hostnetwork(o) {
            hostPort := input_containers[_].ports[_].hostPort
            hostPort > input.parameters.max
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
            not is_exempt(c)
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
            not is_exempt(c)
        }

        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
            not is_exempt(c)
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/privileged-containers.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspprivilegedcontainer
  annotations:
    metadata.gatekeeper.sh/title: "Privileged Container"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls the ability of any container to enable privileged mode.
      Corresponds to the `privileged` field in a PodSecurityPolicy. For more
      information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged
spec:
  crd:
    spec:
      names:
        kind: K8sPSPPrivilegedContainer
      validation:
        openAPIV3Schema:
          type: object
          description: >-
            Controls the ability of any container to enable privileged mode.
            Corresponds to the `privileged` field in a PodSecurityPolicy. For more
            information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspprivileged

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            c := input_containers[_]
            not is_exempt(c)
            c.securityContext.privileged
            msg := sprintf("Privileged container is not allowed: %v, securityContext: %v", [c.name, c.securityContext])
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/proc-mount.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspprocmount
  annotations:
    metadata.gatekeeper.sh/title: "Proc Mount"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls the allowed `procMount` types for the container. Corresponds to
      the `allowedProcMountTypes` field in a PodSecurityPolicy. For more
      information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowedprocmounttypes
spec:
  crd:
    spec:
      names:
        kind: K8sPSPProcMount
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls the allowed `procMount` types for the container. Corresponds to
            the `allowedProcMountTypes` field in a PodSecurityPolicy. For more
            information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowedprocmounttypes
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
            procMount:
              type: string
              description: >-
                Defines the strategy for the security exposure of certain paths
                in `/proc` by the container runtime. Setting to `Default` uses
                the runtime defaults, where `Unmasked` bypasses the default
                behavior.
              enum:
                - Default
                - Unmasked
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspprocmount

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            c := input_containers[_]
            not is_exempt(c)
            allowedProcMount := get_allowed_proc_mount(input)
            not input_proc_mount_type_allowed(allowedProcMount, c)
            msg := sprintf("ProcMount type is not allowed, container: %v. Allowed procMount types: %v", [c.name, allowedProcMount])
        }

        input_proc_mount_type_allowed(allowedProcMount, c) {
            allowedProcMount == "default"
            lower(c.securityContext.procMount) == "default"
        }
        input_proc_mount_type_allowed(allowedProcMount, c) {
            allowedProcMount == "unmasked"
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
            c.securityContext.procMount
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
            c.securityContext.procMount
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
            c.securityContext.procMount
        }

        get_allowed_proc_mount(arg) = out {
            not arg.parameters
            out = "default"
        }
        get_allowed_proc_mount(arg) = out {
            not arg.parameters.procMount
            out = "default"
        }
        get_allowed_proc_mount(arg) = out {
            not valid_proc_mount(arg.parameters.procMount)
            out = "default"
        }
        get_allowed_proc_mount(arg) = out {
            out = lower(arg.parameters.procMount)
        }

        valid_proc_mount(str) {
            lower(str) == "default"
        }
        valid_proc_mount(str) {
            lower(str) == "unmasked"
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/read-only-root-filesystem.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspreadonlyrootfilesystem
  annotations:
    metadata.gatekeeper.sh/title: "Read Only Root Filesystem"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Requires the use of a read-only root file system by pod containers.
      Corresponds to the `readOnlyRootFilesystem` field in a
      PodSecurityPolicy. For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
spec:
  crd:
    spec:
      names:
        kind: K8sPSPReadOnlyRootFilesystem
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Requires the use of a read-only root file system by pod containers.
            Corresponds to the `readOnlyRootFilesystem` field in a
            PodSecurityPolicy. For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspreadonlyrootfilesystem

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg, "details": {}}] {
            c := input_containers[_]
            not is_exempt(c)
            input_read_only_root_fs(c)
            msg := sprintf("only read-only root filesystem container is allowed: %v", [c.name])
        }

        input_read_only_root_fs(c) {
            not has_field(c, "securityContext")
        }
        input_read_only_root_fs(c) {
            not c.securityContext.readOnlyRootFilesystem == true
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/seccomp.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspseccomp
  annotations:
    metadata.gatekeeper.sh/title: "Seccomp"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls the seccomp profile used by containers. Corresponds to the
      `seccomp.security.alpha.kubernetes.io/allowedProfileNames` annotation on
      a PodSecurityPolicy. For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSeccomp
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls the seccomp profile used by containers. Corresponds to the
            `seccomp.security.alpha.kubernetes.io/allowedProfileNames` annotation on
            a PodSecurityPolicy. For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
            allowedProfiles:
              type: array
              description: >-
                An array of allowed profile values for seccomp on Pods/Containers.

                Can use the annotation naming scheme: `runtime/default`, `docker/default`, `unconfined` and/or
                `localhost/some-profile.json`. The item `localhost/*` will allow any localhost based profile.

                Can also use the securityContext naming scheme: `RuntimeDefault`, `Unconfined`
                and/or `Localhost`. For securityContext `Localhost`, use the parameter `allowedLocalhostProfiles`
                to list the allowed profile JSON files.

                The policy code will translate between the two schemes so it is not necessary to use both.

                Putting a `*` in this array allows all Profiles to be used.

                This field is required since with an empty list this policy will block all workloads.
              items:
                type: string
            allowedLocalhostFiles:
              type: array
              description: >-
                When using securityContext naming scheme for seccomp and including `Localhost` this array holds
                the allowed profile JSON files.

                Putting a `*` in this array will allows all JSON files to be used.

                This field is required to allow `Localhost` in securityContext as with an empty list it will block.
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspseccomp

        import data.lib.exempt_container.is_exempt

        container_annotation_key_prefix = "container.seccomp.security.alpha.kubernetes.io/"

        pod_annotation_key = "seccomp.security.alpha.kubernetes.io/pod"

        naming_translation = {
            # securityContext -> annotation
            "RuntimeDefault": ["runtime/default", "docker/default"],
            "Unconfined": ["unconfined"],
            "Localhost": ["localhost"],
            # annotation -> securityContext
            "runtime/default": ["RuntimeDefault"],
            "docker/default": ["RuntimeDefault"],
            "unconfined": ["Unconfined"],
            "localhost": ["Localhost"],
        }

        violation[{"msg": msg}] {
            not input_wildcard_allowed_profiles
            allowed_profiles := get_allowed_profiles
            container := input_containers[name]
            not is_exempt(container)
            result := get_profile(container)
            not allowed_profile(result.profile, result.file, allowed_profiles)
            msg := get_message(result.profile, result.file, name, result.location, allowed_profiles)
        }

        get_message(profile, file, name, location, allowed_profiles) = message {
            not profile == "Localhost"
            message := sprintf("Seccomp profile '%v' is not allowed for container '%v'. Found at: %v. Allowed profiles: %v", [profile, name, location, allowed_profiles])
        }

        get_message(profile, file, name, location, allowed_profiles) = message {
            profile == "Localhost"
            message := sprintf("Seccomp profile '%v' with file '%v' is not allowed for container '%v'. Found at: %v. Allowed profiles: %v", [profile, file, name, location, allowed_profiles])
        }

        input_wildcard_allowed_profiles {
            input.parameters.allowedProfiles[_] == "*"
        }

        input_wildcard_allowed_files {
            input.parameters.allowedLocalhostFiles[_] == "*"
        }

        input_wildcard_allowed_files {
            "localhost/*" == input.parameters.allowedProfiles[_]
        }

        # Simple allowed Profiles
        allowed_profile(profile, file, allowed) {
            not startswith(lower(profile), "localhost")
            profile == allowed[_]
        }

        # seccomp Localhost without wildcard
        allowed_profile(profile, file, allowed) {
            profile == "Localhost"
            not input_wildcard_allowed_files
            profile == allowed[_]
            allowed_files := {x | x := object.get(input.parameters, "allowedLocalhostFiles", [])[_]} | get_annotation_localhost_files
            file == allowed_files[_]
        }

        # seccomp Localhost with wildcard
        allowed_profile(profile, file, allowed) {
            profile == "Localhost"
            input_wildcard_allowed_files
            profile == allowed[_]
        }

        # annotation localhost with wildcard
        allowed_profile(profile, file, allowed) {
            "localhost/*" == allowed[_]
            startswith(profile, "localhost/")
        }

        # annotation localhost without wildcard
        allowed_profile(profile, file, allowed) {
            startswith(profile, "localhost/")
            profile == allowed[_]
        }

        # Localhost files from annotation scheme
        get_annotation_localhost_files[file] {
            profile := input.parameters.allowedProfiles[_]
            startswith(profile, "localhost/")
            file := replace(profile, "localhost/", "")
        }

        # The profiles explicitly in the list
        get_allowed_profiles[allowed] {
            allowed := input.parameters.allowedProfiles[_]
        }

        # The simply translated profiles
        get_allowed_profiles[allowed] {
            profile := input.parameters.allowedProfiles[_]
            not startswith(lower(profile), "localhost")
            allowed := naming_translation[profile][_]
        }

        # Seccomp Localhost to annotation translation
        get_allowed_profiles[allowed] {
            profile := input.parameters.allowedProfiles[_]
            profile == "Localhost"
            file := object.get(input.parameters, "allowedLocalhostFiles", [])[_]
            allowed := sprintf("%v/%v", [naming_translation[profile][_], file])
        }

        # Annotation localhost to Seccomp translation
        get_allowed_profiles[allowed] {
            profile := input.parameters.allowedProfiles[_]
            startswith(profile, "localhost")
            allowed := naming_translation.localhost[_]
        }

        # Container profile as defined in pod annotation
        get_profile(container) = {"profile": profile, "file": "", "location": location} {
            not has_securitycontext_container(container)
            not has_annotation(get_container_annotation_key(container.name))
            not has_securitycontext_pod
            profile := input.review.object.metadata.annotations[pod_annotation_key]
            location := sprintf("annotation %v", [pod_annotation_key])
        }

        # Container profile as defined in container annotation
        get_profile(container) = {"profile": profile, "file": "", "location": location} {
            not has_securitycontext_container(container)
            not has_securitycontext_pod
            container_annotation := get_container_annotation_key(container.name)
            has_annotation(container_annotation)
            profile := input.review.object.metadata.annotations[container_annotation]
            location := sprintf("annotation %v", [container_annotation])
        }

        # Container profile as defined in pods securityContext
        get_profile(container) = {"profile": profile, "file": file, "location": location} {
            not has_securitycontext_container(container)
            profile := input.review.object.spec.securityContext.seccompProfile.type
            file := object.get(input.review.object.spec.securityContext.seccompProfile, "localhostProfile", "")
            location := "pod securityContext"
        }

        # Container profile as defined in containers securityContext
        get_profile(container) = {"profile": profile, "file": file, "location": location} {
            has_securitycontext_container(container)
            profile := container.securityContext.seccompProfile.type
            file := object.get(container.securityContext.seccompProfile, "localhostProfile", "")
            location := "container securityContext"
        }

        # Container profile missing
        get_profile(container) = {"profile": "not configured", "file": "", "location": "no explicit profile found"} {
            not has_annotation(get_container_annotation_key(container.name))
            not has_annotation(pod_annotation_key)
            not has_securitycontext_pod
            not has_securitycontext_container(container)
        }

        has_annotation(annotation) {
            input.review.object.metadata.annotations[annotation]
        }

        has_securitycontext_pod {
            input.review.object.spec.securityContext.seccompProfile
        }

        has_securitycontext_container(container) {
            container.securityContext.seccompProfile
        }

        get_container_annotation_key(name) = annotation {
            annotation := concat("", [container_annotation_key_prefix, name])
        }

        input_containers[container.name] = container {
            container := input.review.object.spec.containers[_]
        }

        input_containers[container.name] = container {
            container := input.review.object.spec.initContainers[_]
        }

        input_containers[container.name] = container {
            container := input.review.object.spec.ephemeralContainers[_]
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/selinux.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspselinuxv2
  annotations:
    metadata.gatekeeper.sh/title: "SELinux V2"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Defines an allow-list of seLinuxOptions configurations for pod
      containers. Corresponds to a PodSecurityPolicy requiring SELinux configs.
      For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSELinuxV2
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Defines an allow-list of seLinuxOptions configurations for pod
            containers. Corresponds to a PodSecurityPolicy requiring SELinux configs.
            For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
            allowedSELinuxOptions:
              type: array
              description: "An allow-list of SELinux options configurations."
              items:
                type: object
                description: "An allowed configuration of SELinux options for a pod container."
                properties:
                  level:
                    type: string
                    description: "An SELinux level."
                  role:
                    type: string
                    description: "An SELinux role."
                  type:
                    type: string
                    description: "An SELinux type."
                  user:
                    type: string
                    description: "An SELinux user."
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspselinux

        import data.lib.exempt_container.is_exempt

        # Disallow top level custom SELinux options
        violation[{"msg": msg, "details": {}}] {
            has_field(input.review.object.spec.securityContext, "seLinuxOptions")
            not input_seLinuxOptions_allowed(input.review.object.spec.securityContext.seLinuxOptions)
            msg := sprintf("SELinux options is not allowed, pod: %v. Allowed options: %v", [input.review.object.metadata.name, input.parameters.allowedSELinuxOptions])
        }
        # Disallow container level custom SELinux options
        violation[{"msg": msg, "details": {}}] {
            c := input_security_context[_]
            not is_exempt(c)
            has_field(c.securityContext, "seLinuxOptions")
            not input_seLinuxOptions_allowed(c.securityContext.seLinuxOptions)
            msg := sprintf("SELinux options is not allowed, pod: %v, container %v. Allowed options: %v", [input.review.object.metadata.name, c.name, input.parameters.allowedSELinuxOptions])
        }

        input_seLinuxOptions_allowed(options) {
            params := input.parameters.allowedSELinuxOptions[_]
            field_allowed("level", options, params)
            field_allowed("role", options, params)
            field_allowed("type", options, params)
            field_allowed("user", options, params)
        }

        field_allowed(field, options, params) {
            params[field] == options[field]
        }
        field_allowed(field, options, params) {
            not has_field(options, field)
        }

        input_security_context[c] {
            c := input.review.object.spec.containers[_]
            has_field(c.securityContext, "seLinuxOptions")
        }
        input_security_context[c] {
            c := input.review.object.spec.initContainers[_]
            has_field(c.securityContext, "seLinuxOptions")
        }
        input_security_context[c] {
            c := input.review.object.spec.ephemeralContainers[_]
            has_field(c.securityContext, "seLinuxOptions")
        }

        # has_field returns whether an object has a field
        has_field(object, field) = true {
            object[field]
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/users.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspallowedusers
  annotations:
    metadata.gatekeeper.sh/title: "Allowed Users"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls the user and group IDs of the container and some volumes.
      Corresponds to the `runAsUser`, `runAsGroup`, `supplementalGroups`, and
      `fsGroup` fields in a PodSecurityPolicy. For more information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowedUsers
      validation:
        openAPIV3Schema:
          type: object
          description: >-
            Controls the user and group IDs of the container and some volumes.
            Corresponds to the `runAsUser`, `runAsGroup`, `supplementalGroups`, and
            `fsGroup` fields in a PodSecurityPolicy. For more information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups
          properties:
            exemptImages:
              description: >-
                Any container that uses an image that matches an entry in this list will be excluded
                from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.

                It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)
                in order to avoid unexpectedly exempting images from an untrusted repository.
              type: array
              items:
                type: string
            runAsUser:
              type: object
              description: "Controls which user ID values are allowed in a Pod or container-level SecurityContext."
              properties:
                rule:
                  type: string
                  description: "A strategy for applying the runAsUser restriction."
                  enum:
                    - MustRunAs
                    - MustRunAsNonRoot
                    - RunAsAny
                ranges:
                  type: array
                  description: "A list of user ID ranges affected by the rule."
                  items:
                    type: object
                    description: "The range of user IDs affected by the rule."
                    properties:
                      min:
                        type: integer
                        description: "The minimum user ID in the range, inclusive."
                      max:
                        type: integer
                        description: "The maximum user ID in the range, inclusive."
            runAsGroup:
              type: object
              description: "Controls which group ID values are allowed in a Pod or container-level SecurityContext."
              properties:
                rule:
                  type: string
                  description: "A strategy for applying the runAsGroup restriction."
                  enum:
                    - MustRunAs
                    - MayRunAs
                    - RunAsAny
                ranges:
                  type: array
                  description: "A list of group ID ranges affected by the rule."
                  items:
                    type: object
                    description: "The range of group IDs affected by the rule."
                    properties:
                      min:
                        type: integer
                        description: "The minimum group ID in the range, inclusive."
                      max:
                        type: integer
                        description: "The maximum group ID in the range, inclusive."
            supplementalGroups:
              type: object
              description: "Controls the supplementalGroups values that are allowed in a Pod or container-level SecurityContext."
              properties:
                rule:
                  type: string
                  description: "A strategy for applying the supplementalGroups restriction."
                  enum:
                    - MustRunAs
                    - MayRunAs
                    - RunAsAny
                ranges:
                  type: array
                  description: "A list of group ID ranges affected by the rule."
                  items:
                    type: object
                    description: "The range of group IDs affected by the rule."
                    properties:
                      min:
                        type: integer
                        description: "The minimum group ID in the range, inclusive."
                      max:
                        type: integer
                        description: "The maximum group ID in the range, inclusive."
            fsGroup:
              type: object
              description: "Controls the fsGroup values that are allowed in a Pod or container-level SecurityContext."
              properties:
                rule:
                  type: string
                  description: "A strategy for applying the fsGroup restriction."
                  enum:
                    - MustRunAs
                    - MayRunAs
                    - RunAsAny
                ranges:
                  type: array
                  description: "A list of group ID ranges affected by the rule."
                  items:
                    type: object
                    description: "The range of group IDs affected by the rule."
                    properties:
                      min:
                        type: integer
                        description: "The minimum group ID in the range, inclusive."
                      max:
                        type: integer
                        description: "The maximum group ID in the range, inclusive."
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspallowedusers

        import data.lib.exempt_container.is_exempt

        violation[{"msg": msg}] {
          fields := ["runAsUser", "runAsGroup", "supplementalGroups", "fsGroup"]
          field := fields[_]
          container := input_containers[_]
          not is_exempt(container)
          msg := get_type_violation(field, container)
        }

        get_type_violation(field, container) = msg {
          field == "runAsUser"
          params := input.parameters[field]
          msg := get_user_violation(params, container)
        }

        get_type_violation(field, container) = msg {
          field != "runAsUser"
          params := input.parameters[field]
          msg := get_violation(field, params, container)
        }

        # RunAsUser (separate due to "MustRunAsNonRoot")
        get_user_violation(params, container) = msg {
          rule := params.rule
          provided_user := get_field_value("runAsUser", container, input.review)
          not accept_users(rule, provided_user)
          msg := sprintf("Container %v is attempting to run as disallowed user %v. Allowed runAsUser: %v", [container.name, provided_user, params])
        }

        get_user_violation(params, container) = msg {
          not get_field_value("runAsUser", container, input.review)
          params.rule = "MustRunAs"
          msg := sprintf("Container %v is attempting to run without a required securityContext/runAsUser", [container.name])
        }

        get_user_violation(params, container) = msg {
          params.rule = "MustRunAsNonRoot"
          not get_field_value("runAsUser", container, input.review)
          not get_field_value("runAsNonRoot", container, input.review)
          msg := sprintf("Container %v is attempting to run without a required securityContext/runAsNonRoot or securityContext/runAsUser != 0", [container.name])
        }

        accept_users("RunAsAny", provided_user) {true}

        accept_users("MustRunAsNonRoot", provided_user) = res {res := provided_user != 0}

        accept_users("MustRunAs", provided_user) = res  {
          ranges := input.parameters.runAsUser.ranges
          res := is_in_range(provided_user, ranges)
        }

        # Group Options
        get_violation(field, params, container) = msg {
          rule := params.rule
          provided_value := get_field_value(field, container, input.review)
          not is_array(provided_value)
          not accept_value(rule, provided_value, params.ranges)
          msg := sprintf("Container %v is attempting to run as disallowed group %v. Allowed %v: %v", [container.name, provided_value, field, params])
        }
        # SupplementalGroups is array value
        get_violation(field, params, container) = msg {
          rule := params.rule
          array_value := get_field_value(field, container, input.review)
          is_array(array_value)
          provided_value := array_value[_]
          not accept_value(rule, provided_value, params.ranges)
          msg := sprintf("Container %v is attempting to run with disallowed supplementalGroups %v. Allowed %v: %v", [container.name, array_value, field, params])
        }

        get_violation(field, params, container) = msg {
          not get_field_value(field, container, input.review)
          params.rule == "MustRunAs"
          msg := sprintf("Container %v is attempting to run without a required securityContext/%v. Allowed %v: %v", [container.name, field, field, params])
        }

        accept_value("RunAsAny", provided_value, ranges) {true}

        accept_value("MayRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}

        accept_value("MustRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}


        # If container level is provided, that takes precedence
        get_field_value(field, container, review) = out {
          container_value := get_seccontext_field(field, container)
          out := container_value
        }

        # If no container level exists, use pod level
        get_field_value(field, container, review) = out {
          not has_seccontext_field(field, container)
          review.kind.kind == "Pod"
          pod_value := get_seccontext_field(field, review.object.spec)
          out := pod_value
        }

        # Helper Functions
        is_in_range(val, ranges) = res {
          matching := {1 | val >= ranges[j].min; val <= ranges[j].max}
          res := count(matching) > 0
        }

        has_seccontext_field(field, obj) {
          get_seccontext_field(field, obj)
        }

        has_seccontext_field(field, obj) {
          get_seccontext_field(field, obj) == false
        }

        get_seccontext_field(field, obj) = out {
          out = obj.securityContext[field]
        }

        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }
        input_containers[c] {
          c := input.review.object.spec.initContainers[_]
        }
        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }
      libs:
        - |
          package lib.exempt_container

          is_exempt(container) {
              exempt_images := object.get(object.get(input, "parameters", {}), "exemptImages", [])
              img := container.image
              exemption := exempt_images[_]
              _matches_exemption(img, exemption)
          }

          _matches_exemption(img, exemption) {
              not endswith(exemption, "*")
              exemption == img
          }

          _matches_exemption(img, exemption) {
              endswith(exemption, "*")
              prefix := trim_suffix(exemption, "*")
              startswith(img, prefix)
          }
---
# Source: gatekeeper-templates/templates/podsecuritypolicies/volumes.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spspvolumetypes
  annotations:
    metadata.gatekeeper.sh/title: "Volume Types"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Restricts mountable volume types to those specified by the user.
      Corresponds to the `volumes` field in a PodSecurityPolicy. For more
      information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
spec:
  crd:
    spec:
      names:
        kind: K8sPSPVolumeTypes
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Restricts mountable volume types to those specified by the user.
            Corresponds to the `volumes` field in a PodSecurityPolicy. For more
            information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
          properties:
            volumes:
              description: "`volumes` is an array of volume types. All volume types can be enabled using `*`."
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spspvolumetypes

        violation[{"msg": msg, "details": {}}] {
            volume_fields := {x | input.review.object.spec.volumes[_][x]; x != "name"}
            field := volume_fields[_]
            not input_volume_type_allowed(field)
            msg := sprintf("The volume type %v is not allowed, pod: %v. Allowed volume types: %v", [field, input.review.object.metadata.name, input.parameters.volumes])
        }

        # * may be used to allow all volume types
        input_volume_type_allowed(field) {
            input.parameters.volumes[_] == "*"
        }

        input_volume_type_allowed(field) {
            field == input.parameters.volumes[_]
        }
---
# Source: gatekeeper-templates/templates/prevent-accidental-deletion/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spreventaccidentaldeletion
spec:
  crd:
    spec:
      names:
        kind: K8sPreventAccidentalDeletion
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
            type: object
            properties:
              annotation:
                description: This annotation allows removal of sensitive resources protected from accidental deletion.
                type: string
              kinds:
                description: A list of resource kinds that will be affected by the constraint.
                type: array
                items:
                  type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spreventaccidentaldeletion
        
        import future.keywords.in
        
        violation[{"msg": msg}] {
        
            input.review.operation == "DELETE"
            not correct_annotation
            correct_kind
        
            msg := sprintf(
                "%v deletion is not allowed.\nTo bypass the constraint, run:\nkubectl annotate %v -n %v %v %v=anything",
                [
                    input.review.object.kind,
                    input.review.object.kind,
                    input.review.object.metadata.namespace,
                    input.review.object.metadata.name,
                    input.parameters.annotation
                ]
            )
        }
        
        correct_annotation {
        
            annotations := input.review.object.metadata.annotations
            value := input.parameters.annotation
        
            some key, _ in annotations
            key == value
        }
        
        correct_kind {
        
            kind := input.review.object.kind
            kinds := input.parameters.kinds
        
            kinds[_] == kind
        }
---
# Source: gatekeeper-templates/templates/reject-loadbalancer-service/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srejectloadbalancerservice
spec:
  crd:
    spec:
      names:
        kind: K8sRejectLoadBalancerService
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srejectloadbalancerservice
        
        violation[{"msg": msg}] {
            input.review.object.kind == "Service"; input.review.object.spec.type == "LoadBalancer"
            msg := "Creation of LoadBalancer Service is not supported. Contact your platform administrator for questions about Load Balancers. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-load-balancer-service/"
        }
---
# Source: gatekeeper-templates/templates/reject-local-storage-empty-dir/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srejectlocalstorageemptydir
spec:
  crd:
    spec:
      names:
        kind: K8sRejectLocalStorageEmptyDir
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
            type: object
            properties:
              volumeAnnotation:
                description: This annotation allows to suppress the warning of the constraint if the violating volumes are listed in the annotation value.
                type: string
              podAnnotation:
                description: This annotation allows to suppress the warning of the constraint if the annotation value is set to "true".
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srejectlocalstorageemptydir
        import future.keywords.in
        
        # violation if volume has no medium.
        violation[{"msg": msg}] {
            volume := get_volumes[_]
            missing(volume.emptyDir, "medium")
            not check_volume_in_annotation(get_metadata, volume)
            not check_pod_annotation(get_metadata)
            msg := sprintf("The volume <%v> emptyDir is using local storage emptyDir. This can prevent autoscaler from scaling down a node where this is running. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-local-storage-emptydir/",[volume])
        }
        
        # violation if medium is not Memory.
        violation[{"msg": msg}] {
            volume := get_volumes[_]
            volume.emptyDir.medium != "Memory"
            not check_volume_in_annotation(get_metadata, volume)
            not check_pod_annotation(get_metadata)
            msg := sprintf("The volume <%v> emptyDir is using local storage emptyDir. This can prevent autoscaler from scaling down a node where this is running. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-local-storage-emptydir/",[volume])
        }
        
        # Get volumes for "Pods"
        get_volumes = res {
            input.review.object.kind == "Pod"
            res := input.review.object.spec.volumes
        }
        
        # Get volumes for resources that use pod templates.
        get_volumes = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.spec.volumes
        }
        
        # Get volumes for "CronJobs"
        get_volumes = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.spec.volumes
        }
        
        # Get metadata for "Pods"
        get_metadata = res {
            input.review.object.kind == "Pod"
            res := input.review.object.metadata
        }
        
        # Get metadata for resources that use pod templates.
        get_metadata = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.metadata
        }
        
        # Get metadata for "CronJobs"
        get_metadata = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.metadata
        }
        
        # Field missing if it does not exist in the object
        missing(obj, field) {
            not obj[field]
        }
        
        check_volume_in_annotation(metadata, volume) {
            some annotation_key, annotation_value in metadata.annotations
            annotation_key == input.parameters.volumeAnnotation
        
            split(annotation_value, ",")[_] == volume.name
        }
        
        check_pod_annotation(metadata) {
            metadata.annotations[input.parameters.podAnnotation] == "true"
        }
---
# Source: gatekeeper-templates/templates/reject-pod-without-controller/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srejectpodwithoutcontroller
spec:
  crd:
    spec:
      names:
        kind: K8sRejectPodWithoutController
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
            type: object
            properties:
              annotation:
                description: This annotation allows to suppress the warning of the constraint if the annotation value is "true".
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srejectpodwithoutcontroller
        
        metadata := input.review.object.metadata
        
        # violation if pod has no ownerReferences.
        violation[{"msg": msg}] {
            input.review.object.kind == "Pod"
            missing(metadata, "ownerReferences")
            not check_annotation
            msg := sprintf("The Pod <%v> does not have any ownerReferences. This can prevent autoscaler from scaling down a node where this is running. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-pod-without-controller",[metadata.name])
        }
        
        # violation if ownerReferences is empty.
        violation[{"msg": msg}] {
            input.review.object.kind == "Pod"
            metadata.ownerReferences == []
            not check_annotation
            msg := sprintf("The Pod <%v> does not have any ownerReferences. This can prevent autoscaler from scaling down a node where this is running. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-no-pod-without-controller",[metadata.name])
        }
        
        # Field missing if it does not exist in the object
        missing(obj, field) {
            not obj[field]
        }
        
        check_annotation {
            metadata.annotations[input.parameters.annotation] == "true"
        }
---
# Source: gatekeeper-templates/templates/resource-requests/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sresourcerequests
spec:
  crd:
    spec:
      names:
        kind: K8sResourceRequests
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sresourcerequests
        
        # violation if container has no resource REQUESTS.
        violation[{"msg": msg}] {
            container := get_containers[_]
            not container.resources.requests
            msg := sprintf("The container named <%v> has no resource requests. Elastisys Welkin® requires resource requests to be set for all containers. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-resources/", [container.name])
        }
        
        # violation if CPU REQUESTS is missing.
        violation[{"msg": msg}] {
            container := get_containers[_]
            missing(container.resources.requests, "cpu")
            msg := sprintf("The container <%v> has no cpu request. Elastisys Welkin® requires resource requests to be set for all containers. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-resources/", [container.name])
        }
        
        # violation if MEMORY REQUESTS is missing.
        violation[{"msg": msg}] {
            container := get_containers[_]
            missing(container.resources.requests, "memory")
            msg := sprintf("The container <%v> has no memory request. Elastisys Welkin® requires resource requests to be set for all containers. Read more at https://elastisys.io/welkin/user-guide/safeguards/enforce-resources/", [container.name])
        }
        
        # Get containers for "Pods"
        get_containers = res {
            input.review.object.kind == "Pod"
            res := input.review.object.spec.containers
        }
        
        # Get containers for resources that use pod templates.
        get_containers = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "DaemonSet",
                "ReplicaSet",
                "Job",
                "ReplicationController"
            ]
            input.review.object.kind == kinds[_]
        
            res := input.review.object.spec.template.spec.containers
        }
        
        # Get containers for "CronJobs"
        get_containers = res {
            input.review.object.kind == "CronJob"
            res := input.review.object.spec.jobTemplate.spec.template.spec.containers
        }
        
        
        # Field missing if it does not exist in the object
        missing(obj, field) {
            not obj[field]
        }
---
# Source: gatekeeper-templates/templates/restrict-pod-disruption-budgets/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srestrictpoddisruptionbudgets
spec:
  crd:
    spec:
      names:
        kind: K8sRestrictPodDisruptionBudgets
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srestrictpoddisruptionbudgets
        
        # Reject PDB if maxUnavailable does not allow at least 1 pod disruption
        violation[{"msg": msg}] {
            input.review.object.kind == "PodDisruptionBudget"
            pdb := input.review.object
        
            pdb.spec.maxUnavailable
        
            not_valid_pdb_max_unavailable(pdb)
            msg := sprintf(
            "PodDisruptionBudget rejected: PodDisruptionBudget <%v> has maxUnavailable of %v, only positive integers or percentages are allowed for maxUnavailable. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-restricted-pod-disruption-budgets/",
            [pdb.metadata.name, pdb.spec.maxUnavailable],
            )
        }
        
        # Reject PDB if minAvailable does not allow at least 1 pod disruption
        violation[{"msg": msg}] {
            input.review.object.kind == "PodDisruptionBudget"
            pdb := input.review.object
        
            pdb.spec.minAvailable
        
            pod_controller_group_kind := pod_controller_groups_kinds[_]
            objs := [controllers | controllers := data.inventory.namespace[pdb.metadata.namespace][pod_controller_group_kind.group][pod_controller_group_kind.kind]]
            obj := objs[_][_]
        
            not mismatched_selector(pdb, obj)
        
            not_valid_pdb_min_available(obj, pdb)
            not replica_set_under_deployment(obj)
        
            msg := sprintf(
            "PodDisruptionBudget rejected: %v <%v> has %v replica(s) but PodDisruptionBudget <%v> has minAvailable of %v, minAvailable should always be lower than replica(s), and not used when replica(s) is set to 1. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-restricted-pod-disruption-budgets/",
            [obj.kind, obj.metadata.name, obj.spec.replicas, pdb.metadata.name, pdb.spec.minAvailable],
            )
        }
        
        # Reject pod controller if connected PDBs maxUnavailable does not allow at least 1 pod disruption
        violation[{"msg": msg}] {
            input.review.object.kind == pod_controller_groups_kinds[_].kind
            obj := input.review.object
            not replica_set_under_deployment(obj)
        
            pdb := data.inventory.namespace[obj.metadata.namespace]["policy/v1"].PodDisruptionBudget[_]
        
            pdb.spec.maxUnavailable
        
            not mismatched_selector(pdb, obj)
        
            not_valid_pdb_max_unavailable(pdb)
            msg := sprintf(
            "%v rejected: %v <%v> has been selected by PodDisruptionBudget <%v> but has maxUnavailable of %v, only positive integers or percentages are allowed for maxUnavailable. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-restricted-pod-disruption-budgets/",
            [obj.kind, obj.kind, obj.metadata.name, pdb.metadata.name, pdb.spec.maxUnavailable],
            )
        }
        
        # Reject pod controller if connected PDBs minAvailable does not allow at least 1 pod disruption
        violation[{"msg": msg}] {
            input.review.object.kind == pod_controller_groups_kinds[_].kind
            obj := input.review.object
            not replica_set_under_deployment(obj)
        
            pdb := data.inventory.namespace[obj.metadata.namespace]["policy/v1"].PodDisruptionBudget[_]
        
            pdb.spec.minAvailable
        
            not mismatched_selector(pdb, obj)
        
            not_valid_pdb_min_available(obj, pdb)
            msg := sprintf(
            "%v rejected: %v <%v> has %v replica(s) but PodDisruptionBudget <%v> has minAvailable of %v, minAvailable should always be lower than replica(s), and not used when replica(s) is set to 1. Read more about this and possible solutions at https://elastisys.io/welkin/user-guide/safeguards/enforce-restricted-pod-disruption-budgets/",
            [obj.kind, obj.kind, obj.metadata.name, obj.spec.replicas, pdb.metadata.name, pdb.spec.minAvailable],
            )
        }
        
        # The type of pod controller to validate
        pod_controller_groups_kinds := [
            {"group": "apps/v1", "kind": "Deployment"},
            {"group": "apps/v1", "kind": "StatefulSet"},
            {"group": "apps/v1", "kind": "ReplicaSet"},
            {"group": "v1", "kind": "ReplicationController"}
        ]
        
        # Do not reject replicasets that are controlled by deployment, instead reject the deployment
        replica_set_under_deployment(obj) {
            obj.kind == "ReplicaSet"
            count([i | obj.metadata.ownerReferences[i].kind == "Deployment"]) > 0
        }
        
        # Check minAvailable if it is integer
        not_valid_pdb_min_available(obj, pdb) {
            not regex.match("^[0-9]+%$", pdb.spec.minAvailable)
            obj.spec.replicas <= pdb.spec.minAvailable
        }
        
        # Check minAvailable if it is percentage
        not_valid_pdb_min_available(obj, pdb) {
            replicas := obj.spec.replicas
            regex.match("^[0-9]+%$", pdb.spec.minAvailable)
            percentage_num := to_number(replace(pdb.spec.minAvailable, "%", ""))
            min_available := ceil((percentage_num/100)*replicas)
        
            replicas <= min_available
        }
        
        not_valid_pdb_max_unavailable(pdb) {
            pdb.spec.maxUnavailable == 0
        }
        
        not_valid_pdb_max_unavailable(pdb) {
            pdb.spec.maxUnavailable == "0%"
        }
        
        # Check one podDisruptionBudget and pod(controller), returns true if it does not match
        mismatched_selector(pdb, obj) = res {
            r1 := matchLabelsMissingKeys(pdb, obj)
            r2 := any(matchLabelsValues(pdb, obj))
            r3 := match_expressions_exists(pdb, obj)
            r4 := match_expressions_does_not_exist(pdb, obj)
            r5 := any(match_expressions_in(pdb, obj))
            r6 := any(match_expressions_not_in(pdb, obj))
            # Return true if any part of the podDisruptionBudget and pod(controller) does not match
            res := any({r1, r2, r3, r4, r5, r6})
        }
        
        matchLabelsMissingKeys(pdb, obj) = res {
            res3 := {key | pdb.spec.selector.matchLabels[key]}
            res4 := {key | get_labels(obj)[key]}
            res := count(res3 - res4) != 0
        }
        
        matchLabelsValues(pdb, obj) = res {
            res := [x |
                get_labels(obj)[key1] != pdb.spec.selector.matchLabels[key3];
                x := key1 == key3]
        }
        
        match_expressions_exists(pdb, obj) = res {
            keys := { key |
                pdb.spec.selector.matchExpressions[i].operator == "Exists"
                key := pdb.spec.selector.matchExpressions[i].key}
            inputKeys := {key | get_labels(obj)[key]}
            res := count(keys - inputKeys) != 0
        }
        
        match_expressions_does_not_exist(pdb, obj) = res {
            keys := { key |
                pdb.spec.selector.matchExpressions[i].operator == "DoesNotExist"
                key := pdb.spec.selector.matchExpressions[i].key}
            inputKeys := {key | get_labels(obj)[key]}
            res := count(keys & inputKeys) != 0
        }
        
        match_expressions_in(pdb, obj) = res {
            res := [ x |
                pdb.spec.selector.matchExpressions[i].operator == "In"
                key := pdb.spec.selector.matchExpressions[i].key
                x := false == any([y | y := get_labels(obj)[key] == pdb.spec.selector.matchExpressions[i].values[_]])]
        }
        
        match_expressions_not_in(pdb, obj) = res {
            res := [ x |
                pdb.spec.selector.matchExpressions[i].operator == "NotIn"
                key := pdb.spec.selector.matchExpressions[i].key
                x := any([y | y := get_labels(obj)[key] == pdb.spec.selector.matchExpressions[i].values[_]])]
        }
        
        # Get labels for resources that use pod templates.
        get_labels(obj) = res {
            kinds := [
                "Deployment",
                "StatefulSet",
                "ReplicaSet",
                "ReplicationController"
            ]
            obj.kind == kinds[_]
        
            res := obj.spec.template.metadata.labels
        }
---
# Source: gatekeeper-templates/templates/user-crds/template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8susercrds
spec:
  crd:
    spec:
      names:
        kind: K8sUserCRDs
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          properties:
            allowedCRDs:
              type: array
              items:
                type: object
                properties:
                  names:
                    type: array
                    items:
                      type: string
                  group:
                    type: string
            users:
              type: array
              items:
                type: string
            groups:
              type: array
              items:
                type: string
            serviceAccounts:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                  namespace:
                    type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8susercrds
        
        # Check when there are no valid reviews
        violation[{"msg": msg}] {
            review := input.review
            fetchFailedReviews[_]
        
            not any(validUser)
        
            msg := sprintf("User <%v> is not allowed to <%v> CRD %v", [review.userInfo.username, review.operation, review.object.metadata.name])
        }
        
        validUser[v] {
            review := input.review
            v := input.parameters.users[_] == review.userInfo.username
        }
        
        validUser[v] {
            review := input.review
            v := input.parameters.groups[_] == review.userInfo.groups[_]
        }
        
        validUser[v] {
            review := input.review
        
            some i
            serviceAccount := input.parameters.serviceAccounts[i]
            serviceAccount.name == "*"
            regexString := replace("system:serviceaccount:{namespace}:", "{namespace}", serviceAccount.namespace)
            v := regex.match(regexString, review.userInfo.username)
        }
        validUser[v] {
            review := input.review
        
            some i
            allowedServiceAccount := input.parameters.serviceAccounts[i]
            replace_part_1 := replace("system:serviceaccount:{namespace}:{name}", "{namespace}", allowedServiceAccount.namespace)
            serviceAccountString := replace(replace_part_1, "{name}", allowedServiceAccount.name)
            v := serviceAccountString == review.userInfo.username
        }
        
        # Fetch reivews with disallowed crds
        fetchFailedReviews[r]{
            review := input.review
        
            review.object.kind == "CustomResourceDefinition"
        
            not any(validCRDNames)
        
            allowedCRDs := input.parameters.allowedCRDs
        
            r := review
        }
        
        fetchFailedReviews[r]{
            review := input.review
        
            count(input.parameters.allowedCRDs) == 0
        
            r := review
        }
        
        # Allow just listed crds
        validCRDNames[allowed] {
            review := input.review
            allowedCRDs := input.parameters.allowedCRDs
        
            some i
            allowedCRDs[i].group == review.object.spec.group
            allowedCRDs[i].names[_] == review.object.metadata.name
            allowed := true
        }
        
        # Allow all crds
        validCRDNames[allowed] {
            review := input.review
            allowedCRDs := input.parameters.allowedCRDs
        
            some i
            allowedCRDs[i].group == review.object.spec.group
            allowedCRDs[i].names[_] == "*"
            allowed := true
        }
---
# Source: gatekeeper-templates/templates/wait/sa.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: gatekeeper-templates
  labels:
    helm.sh/chart: gatekeeper-templates-0.1.0
    app.kubernetes.io/name: gatekeeper-templates
    app.kubernetes.io/instance: gatekeeper-templates
    app.kubernetes.io/version: "1.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-delete-policy: hook-succeeded
---
# Source: gatekeeper-templates/templates/wait/cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: gatekeeper-templates-wait
  labels:
    helm.sh/chart: gatekeeper-templates-0.1.0
    app.kubernetes.io/name: gatekeeper-templates
    app.kubernetes.io/instance: gatekeeper-templates
    app.kubernetes.io/version: "1.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-delete-policy: hook-succeeded
data:
  wait.sh: |-
    #!/usr/bin/env bash
    
    for template in "${@}"; do
      echo "waiting - ${template}"
      attempts=30
      while [[ "$((attempts--))" -gt 0 ]]; do
        if [[ "$(kubectl get crd "${template}" -o 'jsonpath={.status.conditions[?(@.type=="Established")].status}')" == "True" ]]; then
          echo "established - ${template}"
          continue 2
        fi
        sleep 5
      done
    
      echo "time out - ${template}"
      exit 1
    done
---
# Source: gatekeeper-templates/templates/wait/crb.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: gatekeeper-templates-wait
  labels:
    helm.sh/chart: gatekeeper-templates-0.1.0
    app.kubernetes.io/name: gatekeeper-templates
    app.kubernetes.io/instance: gatekeeper-templates
    app.kubernetes.io/version: "1.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-delete-policy: hook-succeeded
rules:
  - apiGroups:
      - apiextensions.k8s.io
    resources:
      - customresourcedefinitions
    resourceNames:
      - k8sallowedrepos.constraints.gatekeeper.sh
      - k8sdisallowedtags.constraints.gatekeeper.sh
      - k8sdisallowlocalhostseccomp.constraints.gatekeeper.sh
      - k8spspallowedusers.constraints.gatekeeper.sh
      - k8spspallowprivilegeescalationcontainer.constraints.gatekeeper.sh
      - k8spspapparmor.constraints.gatekeeper.sh
      - k8spspcapabilities.constraints.gatekeeper.sh
      - k8spspflexvolumes.constraints.gatekeeper.sh
      - k8spspforbiddensysctls.constraints.gatekeeper.sh
      - k8spspfsgroup.constraints.gatekeeper.sh
      - k8spsphostfilesystem.constraints.gatekeeper.sh
      - k8spsphostnamespace.constraints.gatekeeper.sh
      - k8spsphostnetworkingports.constraints.gatekeeper.sh
      - k8spspprivilegedcontainer.constraints.gatekeeper.sh
      - k8spspprocmount.constraints.gatekeeper.sh
      - k8spspreadonlyrootfilesystem.constraints.gatekeeper.sh
      - k8spspseccomp.constraints.gatekeeper.sh
      - k8spspselinuxv2.constraints.gatekeeper.sh
      - k8spspvolumetypes.constraints.gatekeeper.sh
      - k8srejectloadbalancerservice.constraints.gatekeeper.sh
      - k8srequirenetworkpolicy.constraints.gatekeeper.sh
      - k8sresourcerequests.constraints.gatekeeper.sh
      - k8spreventaccidentaldeletion.constraints.gatekeeper.sh
    verbs:
      - get
---
# Source: gatekeeper-templates/templates/wait/crb.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: gatekeeper-templates-wait
  labels:
    helm.sh/chart: gatekeeper-templates-0.1.0
    app.kubernetes.io/name: gatekeeper-templates
    app.kubernetes.io/instance: gatekeeper-templates
    app.kubernetes.io/version: "1.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-delete-policy: hook-succeeded
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gatekeeper-templates-wait
subjects:
- kind: ServiceAccount
  name: gatekeeper-templates
  namespace: gatekeeper-system
---
# Source: gatekeeper-templates/templates/wait/job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: gatekeeper-templates-wait
  labels:
    helm.sh/chart: gatekeeper-templates-0.1.0
    app.kubernetes.io/name: gatekeeper-templates
    app.kubernetes.io/instance: gatekeeper-templates
    app.kubernetes.io/version: "1.0"
    app.kubernetes.io/managed-by: Helm
  annotations:
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-delete-policy: hook-succeeded
spec:
  activeDeadlineSeconds: 600
  template:
    metadata:
      labels:
        app.kubernetes.io/name: gatekeeper-templates
        app.kubernetes.io/instance: gatekeeper-templates
    spec:
      serviceAccountName: gatekeeper-templates
      restartPolicy: Never
      containers:
        - name: wait
          imagePullPolicy: IfNotPresent
          image: "ghcr.io/elastisys/bitnami/kubectl:1.29.11"
          command:
            - /bin/bash
          args:
            - /scripts/wait.sh
            - k8sallowedrepos.constraints.gatekeeper.sh
            - k8sdisallowedtags.constraints.gatekeeper.sh
            - k8sdisallowlocalhostseccomp.constraints.gatekeeper.sh
            - k8spspallowedusers.constraints.gatekeeper.sh
            - k8spspallowprivilegeescalationcontainer.constraints.gatekeeper.sh
            - k8spspapparmor.constraints.gatekeeper.sh
            - k8spspcapabilities.constraints.gatekeeper.sh
            - k8spspflexvolumes.constraints.gatekeeper.sh
            - k8spspforbiddensysctls.constraints.gatekeeper.sh
            - k8spspfsgroup.constraints.gatekeeper.sh
            - k8spsphostfilesystem.constraints.gatekeeper.sh
            - k8spsphostnamespace.constraints.gatekeeper.sh
            - k8spsphostnetworkingports.constraints.gatekeeper.sh
            - k8spspprivilegedcontainer.constraints.gatekeeper.sh
            - k8spspprocmount.constraints.gatekeeper.sh
            - k8spspreadonlyrootfilesystem.constraints.gatekeeper.sh
            - k8spspseccomp.constraints.gatekeeper.sh
            - k8spspselinuxv2.constraints.gatekeeper.sh
            - k8spspvolumetypes.constraints.gatekeeper.sh
            - k8srejectloadbalancerservice.constraints.gatekeeper.sh
            - k8srequirenetworkpolicy.constraints.gatekeeper.sh
            - k8sresourcerequests.constraints.gatekeeper.sh
            - k8spreventaccidentaldeletion.constraints.gatekeeper.sh
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsNonRoot: true
          resources:
            null
          volumeMounts:
            - name: scripts
              mountPath: /scripts
      securityContext:
        seccompProfile:
          type: RuntimeDefault
      volumes:
      - name: scripts
        configMap:
          name: gatekeeper-templates-wait

